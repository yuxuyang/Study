LeetCode

### **two sum**

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].

Answer: because we need travel the whole list if there is no answer, if there is a answer that match
then we will return its index.

By using HashMap, when first putting value and its index into the map if there is no value in the HashMap that matches.
then go though all the keys which if there is one match then return, or in the end return null.

### solution
```java
public int[] twoSum(int[] nums, int target){
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i< nums.lengths; i++){
         if(map.containsKey(target-nums[i])) {
                return (maps.get(target-nums[i]), i );
         }
         map.put(nums[i], i);
    }
    return null;
}
Time complexity: O(n)
Space complexity: O(n)
```





# Coursera Class Stanford  Algorithms

## Integer Multiplication
   the grade-school Algorithm:
            n rows * <= 2n operations(per rows)
            upshot: operations orverall <= constant (like 4)* $ n^2 $
 ## the Karatsuba Multiplication
           x=1234 y= 4567 then seperate a = 56, b = 78, c = 12, d = 34
           step 1: a*c
           step 2: b*d
           step 3: (a+b)(c+d)
           step4: 3-2-1
           step 5: step1*10000 + step2 + step 4*100
A Recursive Algorithm
​        write x = $x = 10^{n/2}a +b  \, and  \, y = 10^{n/2}c+d.$ where$ \, abcd \,are\, {n/2} \,$numbers then$x*y =(10^n)ac + 10^{n/2}(ad+bc)+db  $

Idea: Recursively compute ac,ad,bc,bd, then compute it and return the result back.
 base case:  basic mutiplication.


![karatsuba](/Users/yuxuyang/Desktop/面试/images/WX20170223-230925@2x.png)

## Merge Sort

Merge Sort requires: $<= 6n {\log_2 n} + 6n \, operations \, to \, sort \, n\,numbers.$

Merge Sort: Analysis

​	(assuming n = power of 2)

​    the lowest level of this tree is ${\log_2 n}$ , every element in the lowest level is a single element.

​        

### Guiding Principle #1

"worst- case analysis" : our running time bound holds for every input of length n.

"average -case" analysis

benchmarks

require domain knowledge for the last two analysis 

### Guiding Principle #2

no attention on constant factors, lower-order terms.

Justifications: way easier;constants depends or architecture/ complier/ programmer anyways; lose very little predicitvie power



### Guiding Principle #3

Asymptotic analysis: focus on running time for large input sizes n.

Fast algorithm = worst-case running time grows slowly with input size.  the best is linear time. 



### Asymptotic Analyis 

#### The Gist :

#### vocabulary for the design and analysis of algorithms 

Purpose: Suppress constant factors and lower-order terms -> irrelevant for large inputs.

Terminology:  $O(nlogn)$ when n = input size. 

#### Big-Oh Notation

proof something is wrong by contradiction. 

#### Big Omega and Theta

$\Omega$ bigger than c*f(n) that n>= n0

$\Theta$ bigger and smaller.

little-Oh Notation  for all constants c>0, 

## quiz

```java
import java.util.*;

public class Karatsuba {
	

	public static long cal(long x, long y){
		long aLength = String.valueOf(x).length();
		long bLength = String.valueOf(y).length();
		System.out.println(aLength +" "+bLength);
		if ( (aLength == 1) 
			&& (bLength == 1) )
		{
			return x*y;
		} else {
			long a = x / (long)(Math.pow(10,aLength/2));
			long b = x % (long)(Math.pow(10,aLength/2));
			long c = y / (long)(Math.pow(10,bLength/2));
			long d = y % (long)(Math.pow(10,bLength/2));
			System.out.println(a+" "+b+" "+c+" "+d);
			long a1 = cal(a,c);
			long d1 = cal(b,d);
			long adbc = cal(a+b, c+d)-a1-d1;
			return (long) Math.pow(10,(aLength+bLength)/2)* a1 + (long)Math.pow(10,((aLength+bLength)/4)) * adbc + d1;
		}
	}

	public static void main(String [] args){
		Scanner in = new Scanner(System.in);
		long x = in.nextLong();
		long y = in.nextLong();
		long answer = cal(x,y);
		System.out.println(answer);
	}
}
```





























# Algrithms By Princeton 

Event.waitUntil takes a promise and cache.open returns one.

Here is how should a fetch work for cache response to url: 

```javascript
self.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open('wittr-static-v1').then(function(cache) {
      return cache.addAll([
        '/',
        'js/main.js',
        'css/main.css',
        'imgs/icon.png',
        'https://fonts.gstatic.com/s/roboto/v15/2UX7WLTfW3W8TclTUvlFyQ.woff',
        'https://fonts.gstatic.com/s/roboto/v15/d-6IYplOFocCacKzxwXSOD8E0i7KZn-EPnyo3HZu7kw.woff'
      ]);
    })
  );
});

self.addEventListener('fetch', function(event) {
  // TODO: respond with an entry from the cache if there is one.
  // If there isn't, fetch from the network.
  event.respondWith(
    caches.open('wittr-static-v1').then(function(cache){
      return cache.match(event.request).then(function(response){
        if(response){
          return response;
        }

        return fetch(event.request).then(function(networkResponse){
            cache.put(event.request, networkResponse.clone());
          return networkResponse;
        });
      });
    })
  );
});
```

但是最简洁的方法是

```javascript
self.addEventListener('fetch', function(event){
  event.respondWith(
  	caches.match(event.request).then(function(response){
      if (response) return response;
      return fetch(event.request);
  	})
  );
});
```

怎么keep 一个cache version 一直update， 从不同的old 版本

```javascript
self.addEventListener('activate', function(event) {
  event.waitUntil(
    caches.keys().then(function(cacheNames){
      return Promise.all(
        cacheNames.filter(function(cacheName){
          return cacheName.startsWith('wittr-') &&
                cacheName != staticCacheName;
        }).map(function(cacheName){
          return cache.delete(cacheName);
        })
      );
    })
  );
});
```

```javascript
navigator.serviceWorker.register('/sw.js').then(function(reg) {
    // TODO: if there's no controller, this page wasn't loaded
    // via a service worker, so they're looking at the latest version.
    // In that case, exit early
    if (!navigator.serviceWorker.controller){
      return;
    }

    // TODO: if there's an updated worker already waiting, call
    // indexController._updateReady()
    if (reg.waiting){
      indexController._updateReady();
      return;     
    }
    // TODO: if there's an updated worker installing, track its
    // progress. If it becomes "installed", call
    // indexController._updateReady()
    if (reg.installing) {
      reg.installing.addEventListener('statechange', function(){
        if (this.state == 'installed'){
          indexController._updateReady();
        }
        return;  
      });
    }

    // TODO: otherwise, listen for new installing workers arriving.
    // If one arrives, track its progress.
    // If it becomes "installed", call
    // indexController._updateReady()
    reg.addEventListener('updatefound', function(){
      reg.installing.addEventListener('statechange', function(){
        if (this.state == 'installed'){
          indexController._updateReady();
        }
        return;  
      });
    });
  });
};
```

怎样用cursor来遍历 IndexedDB

```javascript
// people by age
dbPromise.then(function(db) {
  var tx = db.transaction('people');
  var peopleStore = tx.objectStore('people');
  var ageIndex = peopleStore.index('age');

  return ageIndex.getAll();
}).then(function(people) {
  console.log('People by age:', people);
});

// Using cursors
dbPromise.then(function(db) {
  var tx = db.transaction('people');
  var peopleStore = tx.objectStore('people');
  var ageIndex = peopleStore.index('age');

  return ageIndex.openCursor();
}).then(function(cursor) {
  if (!cursor) return;
  return cursor.advance(2);
}).then(function logPerson(cursor) {
  if (!cursor) return;
  console.log("Cursored at:", cursor.value.name);
  // I could also do things like:
  // cursor.update(newValue) to change the value, or
  // cursor.delete() to delete this entry
  return cursor.continue().then(logPerson);
}).then(function() {
  console.log('Done cursoring');
});
```